# Сам код алгоритма

```csharp
using System;

class Program
{
	static void Main()
	{
	// ###############  Входные данные  ##################

		//n - число городов, N - число итераций
		//E - энергия, целевая функция (длина пути)
		//T - температура,  tau - шаг уменьшения температуры
		int n = 10, N = 1000;
		double E = 0.0, T = 30.0, tau = 0.02;

		//C - конфигурация (перестановка набора 012...n-1)
		int[] C = new int[n];
		//Определим начальную конфигурацию
		for(int i=0; i<n; i++) C[i] = i;

		//L[i,j] - расстояние между городами i и j
		double[ , ] L = new double[n,n];

		//( P[0,k], P[1,k] ) - координаты (x,y) города k
		double[ , ] P =
		{{-2.0, -3.0, 0.0, 3.4, 1.8, -1.0, -1.6, 0.3, 1.5, 0.9},
		{-1.4, 1.2, 4.0, 0.8, -1.1, -0.3, 0.6, 1.3, 0.5, -0.3}};

		//Заполняем матрицу расстояний L{i,j}
		for(int i=0; i<n; i++)
		{
			for(int j=0; j<n; j++)
			{
				L[i,j] = Math.Sqrt(
				(P[0,i]-P[0,j])*(P[0,i]-P[0,j]) +
				(P[1,i]-P[1,j])*(P[1,i]-P[1,j]) );
			}
		}

		//Печать начальной конфигурации
		Console.WriteLine("start config");
		printC(n, C); //Метод (ниже) для печати массива C

		for(int k=1; k<n; k++) E = E + L[C[k-1], C[k]];
		Console.WriteLine("   E = " + E);
		E = 0.0;


	// #############  Выполнение программы  ################

		Annealing ann = new Annealing();


		//Выполняем основной метод
		ann.Boltzmann(n, N, ref C, L, ref E, ref T, tau);
		Console.WriteLine("result config");
		printC(n, C);
		Console.WriteLine("   E = " + E + ", T = " + T);
		Console.WriteLine();
		Console.ReadKey();
	}

	//Вспомогательный метод для печати массива конфигурации
	static public void printC(int n, int[] C)
	{
		for (int i = 0; i < n; i++)
		Console.WriteLine(" " + C[i]);
	}
}


//Реализация алгоритма методами Boltzmann, trans, path
class Annealing
{
	Random rnd = new Random();

	//Метод-функция копирует массив C в массив copy
	public int[] copy(int n, int[] C)
	{
		int[] copyC = new int[n];
		for(int i=0; i<n; i++) copyC[i] = C[i];
		return copyC;
	}

	public void Boltzmann(int n, int N, ref int[] C, double[,] L,
		ref double E, ref double T, double tau)
	{
		int[] newC = new int[n]; newC = copy(n, C);
		int[] minC = new int[n]; minC = copy(n, C);


		double Enew, Eold, Emin, delta;

		Eold = path(n, C, L);
		Emin = Eold;

		for (int i = 0; i < N; i++)
		{
			//Изменяем конфигурацию
			trans(n, ref newC, ref rnd);

			//Вычисляем новую длину пути
			Enew = path(n, newC, L);
			delta = Math.Exp((Eold - Enew)/T);

			if(rnd.NextDouble() < delta)
			{
				Eold = Enew;
				C = copy(n, newC);
				if(Enew < Emin)
				{
					Emin = Enew; minC = copy(n, newC);
				}
			}

			//Уменьшаем температуру
			T = T - tau;
		}

		C = copy(n, minC);
		E = Emin;
	}

	//Метод trans изменяет конфигурацию (путь)
	//переставляя местами два города
	static public void trans(int n, ref int[] C, ref Random rnd)//, ref Random rnd
	{
		int i = rnd.Next(n-1) + 1;
		int j = rnd.Next(n-1) + 1;
		int k = C[i];
		C[i] = C[j];
		C[j] = k;
	}

	//Метод path вычисляет длину пути
	static public double path(int n, int[] C, double[,] L)
	{
		double S = 0;
		for(int k=1; k<n; k++) S = S + L[C[k-1], C[k]];
		return S;
	}
}
```

# Основные компоненты алгоритма:

**1. Начальная конфигурация и энергия:**

- Конфигурация `C` — это начальная перестановка городов, которую мы пытаемся оптимизировать.
- `E` — энергия текущей конфигурации, которая в данной задаче представлена длиной пути.

**2. Метод `Boltzmann`:**

- **Копирование конфигурации:** Сначала создаются копии текущей и минимальной конфигураций (`newC`, `minC`).
- **Вычисление начальной длины пути:** `Eold` вычисляется с помощью метода `path`, который суммирует длины между городами на основе матрицы расстояний `L`.
- **Основной цикл:** Выполняется `N` итераций, в каждой из которых:
  - **Изменение конфигурации:** Метод `trans` случайным образом меняет местами два города в конфигурации `newC`.
  - **Вычисление новой энергии:** `Enew` — это длина пути новой конфигурации.
  - **Проверка перехода:** Генерируется случайное число эпсилон (принадлежит отрезку 0, 1). Вычисляется вероятность перехода `delta` через экспоненциальное выражение, основанное на разнице энергий (`Eold - Enew`) и текущей температуре `T`. Если эпсилон меньше `delta`, новая конфигурация принимается.
  - **Обновление минимальной энергии:** Если новая энергия `Enew` меньше ранее зафиксированной минимальной энергии `Emin`, обновляется `Emin` и минимальная конфигурация `minC`.
  - **Уменьшение температуры:** Температура `T` понижается на величину `tau`, что уменьшает вероятность принятия более "плохих" решений с течением времени.

**3. Метод `trans`:**

- Этот метод отвечает за небольшие изменения в конфигурации: случайно выбираются два города, и их позиции меняются местами. Это необходимо для поддержания разнообразия решений и поиска глобального минимума.

**4. Метод `path`:**

- Вычисляет длину пути для данной конфигурации C на основе матрицы расстояний L. Это просто суммирование расстояний между последовательными городами в конфигурации.

# Основная идея метода:

Метод отжига использует принцип постепенного "охлаждения" системы, чтобы избежать попадания в локальные минимумы и стремиться к глобальному минимуму. На начальных этапах система более "горячая" и может принимать менее оптимальные конфигурации, что позволяет исследовать большее пространство решений. Со временем вероятность принятия невыгодных переходов уменьшается, что способствует стабилизации на одном из локальных минимумов, который, надеемся, близок к глобальному оптимуму.
