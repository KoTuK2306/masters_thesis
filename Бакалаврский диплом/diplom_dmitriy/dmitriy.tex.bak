\documentclass[a4paper]{report}

\def\baselinestretch{1.1}
\usepackage[14pt]{extsizes}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{indentfirst}
\usepackage{mathrsfs}

%%%%%%%%%%%%%%%%% Символы, графика %%%%%%%%%%%%%%%%%%%%%

\usepackage[T2A]{fontenc}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\newcommand\dsone{\mathds{H}}
\usepackage{graphicx}
\usepackage{color}
\usepackage[pdftex,colorlinks,linkcolor=blue,citecolor=blue]{hyperref}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{array}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

%%%%%%%%% Разметка страницы %%%%%%%%%

\bibliographystyle{babel}
\renewcommand{\thetable}{\arabic{table}}
\usepackage{indentfirst}
\topmargin=-1.5cm %отступ сверху
\oddsidemargin=0.4cm %отступ слева (нечетные страницы)
\evensidemargin=0.4cm %(четные страницы)
\textwidth=16cm %ширина текста
\textheight=24cm
\tolerance=800
\parskip=1ex

\pagestyle{plain}

\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstset{
    extendedchars=\true,
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=3pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=1,
    basicstyle=\fontsize{10}{12}\selectfont\ttfamily
}

\begin{document}

\begin{titlepage}
    \begin{center}
        Министерство науки и высшего образования РФ\\
        ФГБОУ ВО «Тверской государственный университет»\\
        Математический факультет\\
        Направление 02.03.01 Математика и компьютерные науки\\
        Профиль <<Математическое и компьютерное моделирование>>
    \end{center}

    \vspace{2.5cm}
    \begin{center}

        {ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА }


        \vspace{1.0cm}
        \large{Вычисление операторных экспонент в базисе Паули}


        \vspace{1.5cm}
    \end{center}



    \begin{flushright}
        \begin{minipage}{80mm}
            Автор:\\
            Алешин Дмитрий Алексеевич

            \vspace{1.0cm}
            Научный руководитель:\\
            д. ф.-м. н. Цирулёв А.Н.

        \end{minipage}
    \end{flushright}


    \vspace{1.6cm}
    \noindent Допущен к защите:\\
    Руководитель ООП:\\[1cm]
    \underline{\qquad \qquad \qquad \qquad \qquad }
    В.П. Цветков \\
    \vspace{2.3cm}



    \begin{center}
        Тверь 2023
    \end{center}

    \date{}
\end{titlepage}

\setcounter{page}{2}

\tableofcontents
\newpage

% Abstract
\addcontentsline{toc}{chapter}{\hspace{7mm} Введение}

%##################### Введение ###############################

\section*{Введение}

В современном математическом моделировании конечномерные малоразмерные квантовые системы являются предметом пристального исследования. Такие системы моделируют особое, недавно обнаруженное, состояние вещества. Материалы, построенные на основе таких состояний называются топологическими \cite{Jeonghwan2023}. Одно из основных математических задач, которые возникают при исследовании квантовых систем, является вычисление операторных экспонент от гамильтонианов таких систем. Операторная экспонента может моделировать унитарную эволюцию системы, то есть иметь вид $\text{e}^{-it\hat{H}}$, или оператор плотности состояния квантовой подсистемы в термодинамическом равновесии, то есть подсистемы, находящиеся в контакте с окружающей средой - термостатом.

Для малоразмерных квантовых систем гамильтонианы, как правило, имеют достаточно простой вид, так что для них актуальной является задача прямого программного вычисления операторных экспонент. При этом вычислительные алгоритмы должны быть разработаны отдельно для каждого специального класса малоразмерных квантовых систем. Данная выпускная квалификационная работа посвящена разработке и программной реализации одного из таких алгоритмов, а именно алгоритма вычисления операторных экспонент для системы трёх кубитов с гамильтонианом специального вида. Этот гамильтониан имеет трёхпараметрическую форму и представлен суммой трёх операторов Паули с произвольными коэффициентами.

Цель исследования: изучить свойства операторной экспоненты для трехкубитных квантовых систем и разработать алгоритмы её вычисления с помощью разложения генерирующего оператора.

Основные задачи:
\begin{enumerate}
    \item{Изучить основные свойства базиса Паули}
    \item{Рассмотреть возможные типы однородных трехкубитных гамильтонианов }
    \item{Разработать алгоритм вычисления операторной экспоненты для трёх кубитов в базисе Паули}
\end{enumerate}

Объектом исследования является формула вычисления операторной экспоненты в базисе Паули. Предметом исследования является разработка алгоритма и программная реализация метода, позволяющего вычислить операторную экспоненту для трёх кубитов в базисе Паули.

В работе присутствуют две главы: первая ознакомительная, которая рассказывает о базисе Паули и его связи со стандартным базисом, а вторая глава посвящена операторной экспоненте, разложению гамильтониана, вычислению операторных экспонент для сумм коммутирующих и антикоммутирующих гамильтонианов и алгоритмам прямого вычисления операторной экспоненты. Кроме того, в работе представлена программная реализация вычисления операторной экспоненты для трех кубитов в базисе Паули на языке программирования $C_{\#}$. В заключении сделаны выводы по проделанной работе. Список литературы состоит из 6 источников. В приложении приведен исходный код реализации вычисления операторной экспоненты для трех кубитов в базисе Паули на языке программирования.

Для написания квалификационной работы были применены следующие методы научного исследования: анализ литературы, изучение и обобщение информации, моделирование и проектирование.

В качестве основы для исследования использовались статьи российских и зарубежных ученых, посвященные темам, связанным с темой данной работы.

Всюду в работе используется система единиц, в которой постоянная Планка $\hbar = 1$ и скорость света $c = 1$, так что энергия измеряется (собственное значение гамильтониана) в обратных сантиметрах.

%####################################################
%################# Глава 1 ##########################
%####################################################

\chapter{Базис Паули}

%##################### Первый параграф первой главы ###############################

\section{Связь стандартного базиса и базиса \mbox{Паули}}

Мы будем рассматривать квантовую систему ${n}$ различных кубитов, где кубит связан с двумерным Гильбертовым пространством ${\mathcal{H}}$ и его двумерным (эрмитово сопряжение) пространством ${\mathcal{H}^\dagger}$. Пусть ${\mathcal{H}_n = \mathcal{H}^{\otimes n}}$ и ${\mathcal{H}_n^\dagger = {(\mathcal{H}^\dagger)}^{\otimes n}}$ будут Гильбертовым пространством системы и его эрмитовым сопряжением, соответственно, и пусть ${L(\mathcal{H}_n) = \mathcal{H}_n \otimes \mathcal{H}^\dagger_n}$ будут пространством линейных операторов, действующих на ${\mathcal{H}}$ и ${\mathcal{H}^\dagger}$ левым и правым сокращениями соответственно. Тогда

$${\dim_\mathbb{C} \mathcal{H}_n = \dim_\mathbb{C} \mathcal{H}_n^\dagger = 2^n,\;\;\;
            \dim_\mathbb{C} L(\mathcal{H}_n) = 2^{2n}.}$$

Будем также считать, что пространство ${L(\mathcal{H}_n)}$ снабжено внутренним произведением Гильберта-Шмидта,

\begin{equation}\tag{1}\label{eq1}
    \langle\hat{A},\hat{B}\rangle = \mathrm{tr}(\hat{A}^\dagger\hat{B}),\;\;\;
    \hat{A},\hat{B} \in L(\mathcal{H}_n),
\end{equation}

\noindent которое является естественным продолжением внутреннего продукта в ${\mathcal{H}_n}$. Вещественное линейное пространство эрмитовых операторов далее обозначается как ${H(\mathcal{H}_n)}$.

\newpage

Пусть ${\{|0\rangle,|1\rangle\}}$ являются ортнормированным базисом в некотором однокубитном пространстве в ${\mathcal{H}}$. Единичная матрица и матрицы Паули,

$${
            \sigma_0 = \begin{pmatrix}1 & 0 \\ 0 & 1\end{pmatrix},\;
            \sigma_1 = \begin{pmatrix}0 & 1 \\ 1 & 0\end{pmatrix},\;
            \sigma_2 = \begin{pmatrix}0 & -i \\ i & 0\end{pmatrix},\;
            \sigma_3 = \begin{pmatrix}1 & 0 \\ 0 & -1\end{pmatrix},\;
        }$$

\noindent определим четыре оператора Паули
\begin{align*}
    \hat{\sigma}_0 = |0\rangle\langle0| + |1\rangle\langle1|,\; \hat{\sigma}_1 = |0\rangle\langle1| + |1\rangle\langle0|,     \\
    \hat{\sigma}_2 = -i|0\rangle\langle1| + i|1\rangle\langle0|,\;  \hat{\sigma}_3 = |0\rangle\langle0| - |1\rangle\langle1|,
\end{align*}

\noindent которые эрмитовы и унитарны одинаково одновременно, и которые составляют основу в ${\mathcal{H}}$. Обратное преобразование дается выражением

$${
            |0\rangle\langle0| = \frac{\hat{\sigma}_0 + \hat{\sigma}_3}{2},\;
            |0\rangle\langle1| = \frac{\hat{\sigma}_1 + i\hat{\sigma}_2}{2},\;
            |1\rangle\langle0| = \frac{\hat{\sigma}_1 - i\hat{\sigma}_2}{2},\;
            |1\rangle\langle1| = \frac{\hat{\sigma}_0 - \hat{\sigma}_3}{2}.
        }$$

Напомним, что для ${k, l, m \in \{1,2,3\} }$ у нас есть ${\mathrm{tr}\hat{\sigma}_k = 0,\; \hat{\sigma}^2_k} = \hat{\sigma}_0$, и

\begin{equation}\tag{2}\label{eq2}
    \hat{\sigma}_k\hat{\sigma}_l = -\hat{\sigma}_l\hat{\sigma}_k, \;\;\; \hat{\sigma}_k\hat{\sigma}_l = i\mathrm{sign}(\pi)\hat{\sigma}_m, \;\;\; (klm) = \pi(123),
\end{equation}

\noindent где ${\pi(123)}$ является перестановкой ${\{1,2,3\}}$.

Существует стандартный\footnote[1]{Мы не используем общепринятый термин <<вычислительный>> , потому что это может вызывать путаницу. Базис Паули и стандартный базис являются вычислительными в одном и том же смысле.} бинарный базис в ${\mathcal{H}_n}$ порожденный ортонормированными базисами ${\{|0\rangle,|1\rangle\}}$ в соответствующих однокубитных пространствах. Математически, положение в тензорном произведении отличает кубиты друг от друга. Поэтому для фиксированного ${n}$, элемент этого базиса и соответствующий ему элемент  двумерного базиса удобно записать в виде
$${
            |k\rangle = |k_1\ldots k_n\rangle = |k_1\rangle \otimes \ldots \otimes |k_n\rangle,\;\;\; \langle k| = \langle k_1\ldots k_n| = \langle k_1|\otimes\ldots\otimes\langle k_n|,
        }$$
\noindent относительно строк ${k_1\ldots k_n,\; (k_1,\ldots,k_n\in\{0, 1\})}$ как двоичное число и обозначая его десятичным представлением ${k}$. Например, ${|101\rangle = |5\rangle}$ и ${|00110\rangle = |6\rangle}$.

В стандартном базисе,
$${
            |u\rangle = \sum_{k=0}^{2^n - 1} u_k |k\rangle, \;\;\; \hat{A} = \sum_{k,l=0}^{2^n - 1} a_{kl} |k\rangle\langle l|,
        }$$
\noindent где ${|u\rangle \in \mathcal{H}_n}$ и ${\hat{A} \in L(\mathcal{H}_n)}$.

Базис Паули ${P(\mathcal{H}_n)}$ в ${L(\mathcal{H}_n)}$ определен как
\begin{equation}\tag{3}\label{eq3}
    {\{\hat{\sigma}_{k_1\ldots k_n}\}}_{k_1,\ldots,k_n\in\{0,1,2,3\}},\;\;\;\hat{\sigma}_{k_1\ldots k_n} = \hat{\sigma}_{k_1}\otimes\ldots\otimes\hat{\sigma}_{k_n},
\end{equation}
\noindent где ${\hat{\sigma}_{0\ldots 0}}$ тождественный оператор. Очевидно, что  ${P(\mathcal{H}_n)}$ состоит из ${4^n}$ элементов. Мы будем использовать сокращенное выражение вида
$${
            \hat{\sigma}_K = \hat{\sigma}_{k_1\ldots k_n},
        }$$

\noindent обозначим строку Паули ${{k_1}\ldots k_n}$, где ${{k_1}\ldots k_n \in \{0,1,2,3\}}$, соответствует заглавной букве ${K}$. При этом мы часто будем рассматривать ${K}$ как число, то есть как десятичное представление строки; понятно, что ${0 \leq K \leq 4^n - 1}$. Обратим внимание, что строка Паули ${K}$ и элемент ${\hat{\sigma}_K}$ базиса Паули полностью определяются друг другом и, следовательно, могут быть отождествлены.

Полезно сравнить ${P(\mathcal{H}_n)}$ со стандартным базисом. Имеем
\begin{equation}\tag{4}\label{eq4}
    \hat{\sigma}_{k_1\ldots k_n} \hat{\sigma}_{k_1\ldots k_n} = \hat{\sigma}_{0\ldots 0}, \;\;\;
    \mathrm{tr} \hat{\sigma}_{0\ldots 0} = 2^n\;\;\;,
    \mathrm{tr}\hat{\sigma}_{k_1\ldots k_n}\Big|_{k_1\ldots k_n \neq 0\ldots0} = 0.
\end{equation}

Базис Паули эрмитов, унитарный и ортогональный относительно скалярного произведения \eqref{eq1}. Обратим внимание, что оператор ${|k\rangle\langle l|}$ из стандартного базиса не унитарный, и не эрмитов, если ${k\neq l}$. Стандартный базис не содержит тождественного оператора, имеющего вид
$${
            \sum_{k=0}^{2^n-1} |k\rangle \langle k|
        }$$
\noindent в этом базисе. В базисе Паули, любой оператор ${\hat{U}}$ из унитарной группы ${U(\mathcal{H}_n)}$ (то есть, ${\hat{U}^\dagger\hat{U}=\hat{\sigma}_{0\ldots0}}$) имеет разложение вида
$${
    \hat{U} = \sum_{i_1,\ldots,i_n\in\{0,1,2,3\}}U_{i_1\ldots i_n}\hat{\sigma}_{i_1\ldots i_n},\;\;\;\hat{U}^\dagger = \sum_{i_1,\ldots,i_n\in\{0,1,2,3\}}\overline{U}_{i_1\ldots i_n}\hat{\sigma}_{i_1\ldots i_n},
    }$$
\noindent где
$${
    \sum_{i_1,\ldots,i_n\in\{0,1,2,3\}}\overline{U}_{i_1\ldots i_n}U_{i_1\ldots i_n} = 1,\;\;\;
    \sum_{
        \begin{smallmatrix}
            i_1,\ldots,i_n,j_1,\ldots,j_n\in\{0,1,2,3\}\\
            (i_1,\ldots,i_n)\neq(j_1,\ldots,j_n)
        \end{smallmatrix}} \overline{U}_{i_1\ldots i_n}U_{j_1\ldots j_n} = 0.
    }$$
\noindent Обратим внимание, что последнее условие может быть очевидно разложено на ${2^{2n-1}(2^n-1)}$ независимых условий.

Эрмитовы операторы разлагаются по базису Паули с вещественными коэффициентами.
\newpage

%##################### Второй параграф первой главы ###############################

\section{Коммутационное и антикоммутационное соотношение}

Коммутационное соотношение - это свойство, которое описывает коммутационные отношения между операторами. Для двух операторов ${A}$ и ${B}$ коммутационное соотношение определяется следующим образом:
$${[A, B] = AB - BA,}$$

\noindent если коммутатор ${[A, B]}$ равен нулю, то операторы ${A}$ и ${B}$ \mbox{коммутируют. Если} же коммутатор не равен нулю, то операторы не коммутируют. В базисе Паули коммутационное соотношение может быть выражено следующим образом:
$${[\sigma_i, \sigma_j] = 2i\varepsilon_{ijk}\sigma_k,}$$

\noindent здесь ${\varepsilon_{ijk}}$ - это символ Леви-Чивиты, который равен 1, если ${i, j, k}$ образуют четную перестановку, -1, если они образуют нечетную перестановку, и 0 в остальных случаях. Это соотношение означает, что операторы Паули не коммутируют между собой, кроме случая, когда ${i = j}$. Например, ${[\sigma_1, \sigma_2] = 2i\sigma_3,}$ ${[\sigma_2,\sigma_3] = 2i\sigma_1}$ и т.д.

Антикоммутационное соотношение - это свойство, которое описывает антикоммутационные отношения между операторами. Для двух операторов ${A}$ и ${B}$ антикоммутационное соотношение определяется следующим образом:
$${\{A, B\} = AB + BA,}$$

\noindent если антикоммутатор ${\{A, B}\}$ равен нулю, то операторы ${A}$ и ${B}$ антикоммутируют. Если же антикоммутатор не равен нулю, то операторы не антикоммутируют. В базисе Паули антикоммутационное соотношение может быть выражено следующим образом:
$${\{\sigma_i, \sigma_j\} = 2\delta_{ij},}$$

\noindent здесь ${\delta_{ij}}$ - это символ Кронекера, который равен 1, если ${i = j}$, и 0 в остальных случаях. Это соотношение означает, что операторы Паули антикоммутируют между собой только в случае, когда ${i \neq j}$. Например, ${\{\sigma_1, \sigma_2\} = 0, \{\sigma_2, \sigma_3\} = 0}$ и т.д.

Коммутационное и антикоммутационное соотношение имеют множество применений в квантовой механике. Например, они используются для описания свойств квантовых систем, таких как спин электрона или квантовые биты. Коммутационное соотношение может быть использовано для вычисления коммутаторов операторов, что позволяет определить, коммутируют ли они между собой. Это важно для определения свойств квантовых систем, таких как энергия или момент импульса.
Антикоммутационное соотношение может быть использовано для вычисления антикоммутаторов операторов, что позволяет определить, антикоммутируют ли они между собой. Это важно для определения свойств квантовых систем, таких как спин электрона или квантовые биты.
Кроме того, коммутационное и антикоммутационное соотношение используются в квантовой теории поля для описания взаимодействия между частицами. Они также используются в квантовой информатике для разработки квантовых алгоритмов и квантовых компьютеров.

Рассмотрим несколько примеров коммутационного и антикоммутационного соответствия в базисе Паули.

\begin{enumerate}
    \item Коммутатор ${\sigma_1}$ и ${\sigma_2}$:
          $${[\sigma_1,\sigma_2] = 2i\epsilon_{12k}\sigma_k = 2i\sigma_3};$$
    \item Антикоммутатор ${\sigma_1}$ и ${\sigma_2}$:
          $${\{\sigma_1,\sigma_2\} = 2\delta_{12}\sigma_0 = 0};$$
    \item Коммутатор ${\sigma_1}$ и ${\sigma_3}$:
          $${[\sigma_1,\sigma_3] = 2i\epsilon_{13k}\sigma_k = -2i\sigma_2};$$
    \item Антикоммутатор ${\sigma_1}$ и ${\sigma_3}$:
          $${\{\sigma_1,\sigma_3\} = 2\delta_{13}\sigma_0 = 0};$$
    \item Коммутатор ${\sigma_2}$ и ${\sigma_3}$:
          $${[\sigma_2,\sigma_3] = 2i\epsilon_{23k}\sigma_k = 2i\sigma_1};$$
    \item Антикоммутатор ${\sigma_2}$ и ${\sigma_3}$:
          $${\{\sigma_2,\sigma_3\} = 2\delta_{23}\sigma_0 = 0}.$$
\end{enumerate}

\newpage

%##################### Третий параграф первой главы ###############################

\section{Коммутирующие элементы в алгебре Ли группы ${SU(2^{n})}$}

Нам понадобится несколько фактов и определений, связанных с базисом Паули и множеством  ${n}$-длины строк Паули,
$${
    \mathrm{Str}_n = \{K=k_1\ldots k_n\}_{k_1,\ldots,k_n\in\{0,1,2,3\} }.
    }$$

Во-первых, рассмотрим множество ${ \mathbb{F}_4=\{0,1,2,3\} }$ как квадгруппу ${\mbox{Клейна}}$ c правилами умножения
$${
            0*k = k,\;\;\; k*k=0, \;\;\; k*l=m,
        }$$
где ${k,l,m\in\{1,2,3\}}$ и ${klm}$ есть любая перестановка 123. Во-вторых, пусть функция ${s:\mathbb{F}_4\times\mathbb{F}_4}\rightarrow\{1,i,-i\}$ определяется значениями
$${
            \begin{array}{l}
                s(0,0)=s(0,k)=s(k,0)=s(k,k)=1,\;\;\;k=1,2,3           \\
                s(1,2)=s(2,3)=s(3,1)=i,\;\;\;s(2,1)=s(3,2)=s(1,3)=-i.
            \end{array}
        }$$

Далее, пусть функция ${S:\mathrm{Str}_n\times\mathrm{Str}_n\rightarrow\{1,-1,i,-i\}, \; (K,L)\mapsto S_{KL}}$, будет определена как произведение
$${
            S_{KL} = s (k_1,l_1)s(k_2,l_2)\ldots s(k_n,l_n), \;\;\; K = k_1k_2\ldots k_n, \;\;\; L=l_1l_2\ldots l_n.
        }$$

Функция ${S}$ симметрична или антисимметрична в зависимости от количества пар ${k_r,l_r}$ (${r}$ это позиция в строках ${K}$ и ${L}$), таких что ${k_r,k_l\in\{1,2,3\}}$ и ${k_r\neq l_r}$, а также в зависимости от относительного порядка в них. Пусть ${\omega^+_{KL}}$ и ${\omega^-_{KL}}$ будут числами пары форм ${(1,2),(2,3),(3,1)}$ и форм ${(2,1),(3,2),(1,3)}$ соответственно, и пусть
${\omega_{KL} = \omega^+_{KL} + \omega^-_{KL}}$. \mbox{Тогда}
\begin{equation}\tag{\normalsize 5}\label{eq5}
    \small S_{KL} = (i)^{\omega_{KL}}(-1)^{\omega^-_{KL}},S_{(KL)} = \frac{S_{KL}}{2}(1+(-1)^{\omega_{KL}}),S_{[KL]}=\frac{S_{KL}}{2}(1-(-1)^{\omega_{KL}}),
\end{equation}

\noindent где круглые и квадратные скобки обозначают симметризацию и антисимметризацию соответственно. Значения ${S_{KL},\;S_{(KL)}}$ и ${S_{[KL]}}$ приведены в Таблице \ref{table2}.

\begin{table}[h!]
    \centering
    \begin{tabular}{ | c | P{1cm} | P{1cm} | P{1cm} | P{1cm} | P{1cm} | P{1cm} | P{1cm} | P{1cm} | }
        \hline
        ${\omega_{KL}\mathrm{mod4}}$     & 0 & 2 & 0      & 2      & 1     & 3     & 1      & 3      \\
        \hline
        ${\omega_{KL}^{-}\mathrm{mod4}}$ & 0 & 1 & 1      & 0      & 0     & 1     & 1      & 0      \\
        \hline\hline
        ${S_{KL}}$                       &   & 1 & ${-1}$ & -1     & ${i}$ & ${i}$ & ${-i}$ & ${-i}$ \\
        \hline
        ${S_{(KL)}}$                     & 1 & 1 & ${-1}$ & ${-1}$ & 0     & 0     & 0      & 0      \\
        \hline
        ${S_{[KL]}}$                     & 0 & 0 & 0      & 0      & ${i}$ & ${i}$ & ${-i}$ & ${-i}$ \\
        \hline
    \end{tabular}
    \caption{Множитель до ${\hat{\sigma}_M}$ в \eqref{eq6} для ${\hat{\sigma}_K\hat{\sigma}_L,\{\hat{\sigma}_K,\hat{\sigma}_L\}}$, и ${[i\hat{\sigma}_K,i\hat{\sigma}_L]}$.}\label{table1}
\end{table}

Теперь композиция двух базисных элементов Паули и их антикоммутатора и коммутатора можно записать в виде компактных выражений, удобных для классического компьютерного программирования:
\begin{equation}\tag{6}\label{eq6}
    \hat{\sigma}_K\hat{\sigma}_L=S_{KL}\hat{\sigma}_M,\;\;\;\{\hat{\sigma}_K,\hat{\sigma}_L\}=S_{(KL)}\hat{\sigma}_M,\;\;\;[i\hat{\sigma}_K, i\hat{\sigma}_L]=-S_{[KL]}\hat{\sigma}_M,
\end{equation}

\noindent где

\begin{equation}\tag{7}\label{eq7}
    \hat{\sigma}_M=\hat{\sigma}_{m_1\ldots m_n}, \;\;\; m_1 = k_1*l_1,\ldots,m_n=k_n*l_n.
\end{equation}

Обратим внимание, что две строки Паули длины ${n}$ могут коммутировать, даже если они имеют разные ненулевые записи в одних и тех же местах. Например, три оператора ${\hat{\sigma}_{11},\;\hat{\sigma}_{22}}$, и ${\hat{\sigma}_{33}}$ взаимно коммутируют. Так же легко увидеть, что унитарная матрица перехода, преобразующая стандартный базис ${\{|i_1\ldots i_n\rangle\langle j_1\ldots j_n|\}}$ в базис Паули, состоит только из элементов ${0,\;\pm1,}$ и ${\pm i}$. В частности
$${|00\ldots0\rangle\langle00\ldots0|\rightarrow\frac{1}{2^n}\sum_{i_1,\ldots,i_n\in\{0,3\}}\hat{\sigma}_{i_1\ldots i_n}.}$$

В более общем виде стандартные ортогональные проекторы могут быть выражены как
$${
    |i_1\ldots i_n\rangle\langle i_1\ldots i_n|_{i_1,\ldots,i_n\in\{0,1\}} = \frac{1}{2^n}\sum_{k_1,\ldots,k_n\in\{0,3\}}\mathcal{X}^{i_1}_{k_1}\cdots\mathcal{X}^{i_n}_{k_n}\:\hat{\sigma}_{k_1\ldots k_n},
    }$$

\noindent где

$${
            \mathcal{X}^0_0=\mathcal{X}^0_3=\mathcal{X}^1_0=1,\;\;\;\mathcal{X}^1_3 = -1.
        }$$

Выражение \eqref{eq6} показывает, во-перых, что множество ${\{i\hat{\sigma}_K\}^{4^n-1}_{K=0}}$ составляет ортонормированный базис в ${\mathfrak{su}(n)}$. И, во-вторых, множество
$${
            \widetilde{P}(\mathcal{H}_n) = \left\{\epsilon\hat{\sigma}_K|K\in\mathrm{Str}_n,\epsilon\in\{\pm1,\pm i\}\right\},
        }$$

\noindent который состоит из ${4^{n+1}}$ элементов, это группа; это называется \mbox{(${n}$-кубитной)} группой Паули. Нормализатор группы Паули,
$${
            \mathcal{C}(\mathcal{H}_n)=\{\hat{U}\in U(\mathcal{H}_n)|\hat{U}\hat{\sigma}_K\hat{U}^\dagger\in\widetilde{P}(\mathcal{H}_n),\;\;\hat{\sigma}_K\in\widetilde{P}(\mathcal{H}_n)\},
        }$$

\noindent называется группой Клиффорда. Исходя из \eqref{eq2}, \eqref{eq4} и \eqref{eq7} получаем следующее утверждение

\textsf{Утверждение 1.}\textit{Взаимные унитарные преобразования базисных операторов Паули подчиняются соотношениям ${\hat{\sigma}_{i_1\ldots i_n}\hat{\sigma}_{k_1\ldots k_n}\hat{\sigma}_{i_1\ldots i_n}=\pm\hat{\sigma}_{i_1\ldots i_n}}$, где знак плюс стоит тогда и только тогда, когда количество троек ${(i_m k_m i_m)_{m\in\{1,\ldots,n\}}}$, удовлетворяют условиям ${i_m\neq k_m},\;i_m\neq0,$ и ${k_m\neq0}$ четности}.

\begin{table}[h!]
    \centering
    \begin{tabular}{ | c | P{1cm} | P{1cm} | P{1cm} | P{1cm} | P{1cm} | P{1cm} | P{1cm} | P{1cm} | }
        \hline
        ${l}$                    & 0                      & 1                      & 2                      & 3                      & 4                      & 5                      & 6                      & 7                      \\
        \hline
        ${l_2 l_1 l_0}$          & 000                    & 001                    & 010                    & 011                    & 100                    & 101                    & 110                    & 111                    \\
        \hline
        ${k_2 k_1 k_0}$          & 011                    & 011                    & 011                    & 011                    & 011                    & 011                    & 011                    & 011                    \\
        \hline
        ${\overline{l}\wedge k}$ & 011                    & 010                    & 001                    & 000                    & 011                    & 010                    & 001                    & 000                    \\
        \hline
        ${l\wedge k}$            & 000                    & 001                    & 010                    & 011                    & 000                    & 001                    & 010                    & 011                    \\
        \hline
        ${l\wedge \overline{k}}$ & 000                    & 000                    & 000                    & 000                    & 100                    & 100                    & 100                    & 100                    \\
        \hline
        ${\hat{\sigma}_{I}}$     & ${\hat{\sigma}_{011}}$ & ${\hat{\sigma}_{012}}$ & ${\hat{\sigma}_{021}}$ & ${\hat{\sigma}_{022}}$ & ${\hat{\sigma}_{311}}$ & ${\hat{\sigma}_{312}}$ & ${\hat{\sigma}_{121}}$ & ${\hat{\sigma}_{322}}$ \\
        \hline
    \end{tabular}
    \caption{Элементы базиса Паули, возникающие для ${k=011}$.}\label{table2}
\end{table}

%####################################################
%################# Глава 2 ##########################
%####################################################

\chapter{Операторная экспонента}

%##################### Первый параграф второй главы ###############################

\section{Разложение гамильтониана}
Операторная экспонента - это математический объект, который используется в квантовой механике для описания эволюции квантовых систем во времени. Она является аналогом обычной экспоненты в классической механике и определяется через ряд Тейлора оператора. Операторная экспонента может быть использована для вычисления эволюционного оператора, который описывает изменение состояния квантовой системы во времени. Она играет важную роль во многих областях квантовой механики, включая теорию поля, теорию квантовой информации и квантовую оптику. Формула для вычисления операторной экспоненты через ряд Маклорена:

$$\text{e}^{\hat{A}} = \sum_{n=0}^{\infty} \frac{1}{n!} \hat{A}^n,$$

\noindent где $\hat{A}$ - оператор, а $\hat{A}^n$ - его $n$-ая степень.

Разложение гамильтониана в базисе Паули - это представление гамильтониана квантовой системы в виде линейной комбинации произведений матриц Паули, которые образуют базис в пространстве состояний системы. Формула для разложения гамильтониана в базисе Паули:
$$
    \begin{matrix}
        \hat{H}= & \sum\limits_{i_1,\ldots,i_n\in\{0,1,2,3\}} & h_{i_1\ldots i_n}\hat{\sigma}_{i_1\ldots i_n}
    \end{matrix}
$$

\noindent где $n$ - число кубитов в системе, $h_i$ - коэффициенты, а $\hat{\sigma}_i$ - операторы Паули, определяемые как:
$$\begin{array}{cc}
        \hat{\sigma}_0 = |0\rangle\langle0| + |1\rangle\langle1|, \quad \hat{\sigma}_1 = |0\rangle\langle1| + |1\rangle\langle0|,    \\
        \hat{\sigma}_2 = -i|0\rangle\langle1| + i|1\rangle\langle0|, \quad \hat{\sigma}_3 = |0\rangle\langle0| - |1\rangle\langle1|.
    \end{array}$$
\noindent Представление гамильтониана в базисе Паули позволяет упростить вычисления в квантовой механике и использовать методы линейной алгебры для решения задач. Кроме того, это разложение может быть использовано для построения квантовых алгоритмов и квантовых вычислений.

\newpage

%##################### Второй параграф второй главы ###############################

\section{Вычисление операторных экспонент для сумм коммутирующих и антикоммутирующих гамильтонианов}
Алгоритм реализован на языке программирования C$\small{\#}$. Выбор был осуществлен в сторону этого языка из-за его удобства и возможности использовать в будущем этот алгоритм как стороннюю библиотеку. Так же этот язык позволяет разрабатывать алгоритм в стиле объектно-ориентированного программирования.

Для начала представим общий вид гамильтониана для трёх кубитов:
$$
    \hat{H} = \sum_{i,j,k\in\{0,1,2,3\}} h_{ijk}\hat{\sigma}_{ijk}.
$$

\noindent Но в нашей работе мы будем использовать гамильтониан, состоящий из трёх слагаемых, в роли которых выступают операторы Паули. Выглядит он следующим образом:
\begin{equation}\tag{8}\label{eq8}
    \hat{H} = a\hat{\sigma}_A + b\hat{\sigma}_B + c\hat{\sigma}_C,
\end{equation}

\noindent где $a, b, c$ --- некоторые коэффициенты, а $\hat{\sigma}_A, \hat{\sigma}_B, \hat{\sigma}_C$ --- операторы Паули.\\

Рассмотрим следующую классификацию гамильтонианов:
\begin{enumerate}
\item $[\hat{\sigma}_A, \hat{\sigma}_B] = [\hat{\sigma}_A, \hat{\sigma}_C] = [\hat{\sigma}_B, \hat{\sigma}_C] = 0$;
\item $\{\hat{\sigma}_A, \hat{\sigma}_B\} = \{\hat{\sigma}_A, \hat{\sigma}_C\} = \{\hat{\sigma}_B, \hat{\sigma}_C\} = 0$;
\item $\{\hat{\sigma}_A, \hat{\sigma}_B\} = 0,\quad [\hat{\sigma}_A, \hat{\sigma}_C] = [\hat{\sigma}_B, \hat{\sigma}_C] = [\hat{\sigma}_A + \hat{\sigma}_B, \hat{\sigma}_C] = 0$;
\item $[\hat{\sigma}_A, \hat{\sigma}_B] = 0,\quad \{\hat{\sigma}_A, \hat{\sigma}_C\} = \{\hat{\sigma}_B, \hat{\sigma}_C\} = 0$.
\end{enumerate}

Пункты 1-3 решаются аналитически, поэтому в этой работе мы не будем их рассматривать. Предметом исследования послужит последний пункт классификации гамильтонианов, подробный алгоритм вычисления которого будет описан в параграфе 2.3.

Опишем какие входные данные имеет наш алгоритм. А именно \mbox{$a, b, c$ --- некоторые} коэффициенты, а $\hat{\sigma}_A, \hat{\sigma}_B, \hat{\sigma}_C$ --- операторы Паули. Перейдём к описанию алгоритму вычисления композиции двух операторов, которая понадобится нам для вычисления операторной экспоненты для трёх кубитов. Пояснение, написанное ниже, объясняет работу на примере двух операторов. Далее $\hat{\sigma}_K$ и $\hat{\sigma}_L$. Для данного алгоритма был реализован класс $Calculation$, состоящий из методов $PauliMatrices, Operations$ и $Factors$. О нём подробнее ниже

Два оператора Паули $\hat{\sigma}_K$ и $\hat{\sigma}_L$ необходимы для расчёта ${\omega\hat{\sigma}_M}$. Далее, в строках 29-51 происходит расчёт индекса ${\hat{\sigma}_M}$.
\begin{lstlisting}[firstnumber=29]
public static string PauliMatrices(string K, string L)
{
    char[] K1 = K.ToCharArray();
    char[] L1 = L.ToCharArray();
    string M = "";
    int a, b, c;
    if (K1.Length == L1.Length)
    {
    	for (int i = 0; i < K1.Length; i++)
    	{
    		a = K1[i] - '0';
    		b = L1[i] - '0';
    		c = Calculation.Operations(a, b);
    		M = M + Convert.ToString(c);
    	}
    	return M;
    }
    else
    {
    	Console.WriteLine("Ошибка размерности кубитов двух операторов");
    	return "";
    };
}
\end{lstlisting}
\noindent В строках 31 и 32 разбиваются строки $K$ и $L$ на массив символов. В строках 39-42 происходит приведение к типу int и вычисление элемента, затем добавление его в строку.

Процедура вычисления элементов у нас начинается в строках 52-60.
\begin{lstlisting}[firstnumber=52]
public static int Operations(int a, int b)
{
	int c;
	if (a == b) c = 0;
	else if (a == 0) c = b;
	else if (b == 0) c = a;
	else c = 6 / (a * b);
	return c;
}
\end{lstlisting}

\noindent Если ${a * a = 0, a * 0 = a, a * b = c}$, то ${a,b,c = 1,2,3}$

Расчет коэффициента $\omega$ описан в строках 61-91 и вычисляется по формуле:
$$
    \omega = (i)^{p+m}(-1)^m,
$$
\noindent где $p$ - количество соответствий 1-2, 2-3, 3-1, а $m$ - количество соответствий 2-1, 2-3, 1-3.
\begin{lstlisting}[firstnumber=61]
public static string Factors(string K, string L)
{
	char[] K1 = K.ToCharArray();
	char[] L1 = L.ToCharArray();
	int a, b, skl, p = 0, m = 0;
	string w = "";
	if (K1.Length == L1.Length)
	{
		for (int i = 0; i < K1.Length; i++)
		{
			a = K1[i] - '0';
			b = L1[i] - '0';
			if (a - b == 1 || a - b == -2) m++;
			if (b - a == 1 || b - a == -2) p++;
			p = p + m;
		}
		if (p % 4 == 0 || p % 4 == 1)
		{
			skl = Convert.ToInt32(Math.Pow(-1, m));
			if (skl == 1) w = "";
			else w = "-1";
		}
		if (p % 4 == 2 || p % 4 == 3)
		{
			skl = Convert.ToInt32(Math.Pow(-1, m + 1));
			if (skl == 1) w = "i";
			else w = "-i";
		}
	}
	return w;
}
\end{lstlisting}

Результатом выполнения данного алгоритма является строка композиции двух операторов Паули.
\newpage

%##################### Третий параграф второй главы ###############################

\section{Алгоритмы прямого вычисления операторной экспоненты}

В этом параграфе будет идти речь о вычислении степеней гамильтониана на основе полученных композиций операторов из параграфа 2.2. Подробнее об алгоритме.

Отправной точкой для этого алгоритма поступят формулы вычисления степеней гамильтониана, полученные аналитически:
\begin{equation}\tag{9}\label{eq9}
    \begin{array}{cc}
        \hat{H}^2 = \hat{\sigma}_0 + 2ab\hat{\sigma}_A\hat{\sigma}_B,\\
        \hat{H}^3 = \hat{H} + 2ab^2\hat{\sigma}_A + 2a^2b\hat{\sigma}_B + 2abc\hat{\sigma}_A\hat{\sigma}_B\hat{\sigma}_C,
    \end{array}
\end{equation}

Для данного алгоритма был реализован класс $Hamiltonian$, состоящий из методов \textit{CountingOperators}, \textit{CalculateSecondDegreeOfHamiltonian} и \textit{CalculateThirdDegreeOfHamiltonian}. О них подробнее ниже.

В строках 95-166 происходит расчёт необходимых операторов для вычисления степеней гамильтониана.
\begin{lstlisting}[firstnumber=95]
public static string[] СountingOperators(string sigma_1, string sigma_2, string sigma_3)
{
	string sigma_12 = Calculation.Factors(sigma_1, sigma_2) + $"*{sigma}_" + Calculation.PauliMatrices(sigma_1, sigma_2);
	string sigma_23 = Calculation.Factors(sigma_2, sigma_3) + $"*{sigma}_" + Calculation.PauliMatrices(sigma_2, sigma_3);
	string sigma_12_indexes = sigma_12.Split("_")[sigma_12.Split("_").Length - 1];
	string sigma_123_draft = Calculation.Factors(sigma_12_indexes, sigma_3) + $"*{sigma}_" + Calculation.PauliMatrices(sigma_12_indexes, sigma_3);
	string sigma_123;

	if (sigma_12.StartsWith("-1"))
	{
		if (sigma_123_draft.StartsWith("-i"))
		{
			sigma_123 = $"i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else if (sigma_123_draft.StartsWith("i"))
		{
			sigma_123 = $"-i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else if (sigma_123_draft.StartsWith("-1"))
		{
			sigma_123 = $"{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else
		{
			sigma_123 = $"-1*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
	}
	else if (sigma_12.StartsWith("-i"))
	{
		if (sigma_123_draft.StartsWith("-i"))
		{
			sigma_123 = $"-1*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else if (sigma_123_draft.StartsWith("i"))
		{
			sigma_123 = $"{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else if (sigma_123_draft.StartsWith("-1"))
		{
			sigma_123 = $"i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else
		{
			sigma_123 = $"-i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
	}
	else if (sigma_12.StartsWith("i"))
	{
		if (sigma_123_draft.StartsWith("-i"))
		{
			sigma_123 = $"{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else if (sigma_123_draft.StartsWith("i"))
		{
			sigma_123 = $"-1*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else if (sigma_123_draft.StartsWith("-1"))
		{
			sigma_123 = $"-i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
		else
		{
			sigma_123 = $"i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
		}
	}
	else
	{
		sigma_123 = sigma_123_draft;
	}
	string[] sigma_array = new string[] { sigma_12, sigma_23, sigma_123 };
	return sigma_array;
}
\end{lstlisting}

В строках 168-171 происходит расчёт второй степени гамильтониана из формулы \eqref{eq9}.
\begin{lstlisting}[firstnumber=168]
public static string СalculateSecondDegreeOfHamiltonian(double alpha, double beta, string[] arrayOfSigma)
{
	return $"{sigma}_000 + {2 * alpha* beta}*{arrayOfSigma[0]}";
}
\end{lstlisting}

В строках 172-175 происходит расчёт третьей степени гамильтониана из формулы \eqref{eq9}.
\begin{lstlisting}[firstnumber=172]
public static string СalculateThirdDegreeOfHamiltonian(double alpha, double beta, double gamma, string sigma_1, string sigma_2, string[] arrayOfSigma)
{
	return $"H + {2 * alpha * Math.Pow(beta, 2)}*{sigma}_{sigma_1}+{2 * Math.Pow(beta, 2) * beta}*{sigma}_{sigma_2} + {2 * alpha * beta * gamma}*{arrayOfSigma[2]}";
}
\end{lstlisting}

\noindent Результатом выполнения данного алгоритма будет две строки \mbox{$H^2$ и $H^3$}.

\newpage

%##################### Заключение ###############################

\addcontentsline{toc}{chapter}{\hspace{7mm} Заключение}
\section*{Заключение}
В работе получены следующие основные результаты:
\begin{enumerate}
    \item{Изучены свойства базиса Паули}
    \item{Исследована связь стандартного базиса и базиса Паули}
    \item{Разработан алгоритм вычисления операторной экспоненты для трёх кубитов в базисе Паули на языке C$\#$}
\end{enumerate}

\newpage

%##################### Список литературы ###############################

\addcontentsline{toc}{chapter}{\hspace{7mm} Литература}
\begin{thebibliography}{99}

    \bibitem{Tsirulev2020}
    V. V. Nikonov, A. N. Tsirulev. \textit{Pauli basis formalism in quantum computations}. Volume 8, No 3, pp. 1 – 14 (2020).\\
    (\href{https:doi.org/10.26456/mmg/2020-831} {\textit{doi:10.26456/mmg/2020-831}})

    \bibitem{Nielsen2010}
    Michael A. Nielsen, Isaac L. Chuang. \textit{Quantum Computation and Quantum Information}. Cambridge University Press The Edinburgh Building, Cambridge CB2 8RU, UK. 2010\\
    (\href{http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf} {\textit{mmrc:201702/W020170224608149940643}})

    \bibitem{Griffiths1995}
    David J. Griffiths. \textit{Introduction to Quantum Mechanics}. Prentice Hall, Upper Saddle River, New Jersey 07458, 1995\\
    (\href{https://www.fisica.net/mecanica-quantica/Griffiths%20-%20Introduction%20to%20quantum%20mechanics.pdf} {\textit{fisica:mecanica-quantica/Griffiths-IntroductionToQuantumMechanics}})

    \bibitem{Goldstein2000}
    Herbert Goldstein. \textit{Classical Mechanics}. 2000

    \bibitem{Rieffel2011}
    Eleanor Rieffel, Wolfgang Polak. \textit{Quantum Computing: A Gentle Introduction}. 2011

    \bibitem{Jeonghwan2023}
    Jeonghwan Ahn, Seoung-Hun Kang, Mao-Hua Du. \textit{Procedures for assessing the stability of proposed topological materials}. Oak Ridge National Laboratory, Oak Ridge, TN 37831, USA. 2023\\
    (\href{https://arxiv.org/abs/2305.09308}{\textit{arXiv:} 2305.09308})

\end{thebibliography}

\newpage
\addcontentsline{toc}{chapter}{\hspace{7mm} Приложение {C\small{$\#$}}}

%##################### Приложение ###############################

\chapter*{Приложение {\huge C{$\#$}}}

\begin{lstlisting}
class Program
{
	static string sigma = "\u03C3";
	static void Main()
	{
		Console.OutputEncoding = Encoding.UTF8;
		Console.Write(" Введите коэффициент первого слагаемого гамильтониана: ");
		string a = Console.ReadLine()!;
		Console.Write(" Введите индексы первого оператора Паули: ");
		string sigma_1 = Console.ReadLine()!;
		Console.Write(" Введите коэффициент второго слагаемого гамильтониана: ");
		string b = Console.ReadLine()!;
		Console.Write(" Введите индексы второго оператора Паули: ");
		string sigma_2 = Console.ReadLine()!;
		Console.Write(" Введите коэффициент третьего слагаемого гамильтониана: ");
		string c = Console.ReadLine()!;
		Console.Write(" Введите индексы третьего оператора Паули: ");
		string sigma_3 = Console.ReadLine()!;
		Console.WriteLine($" Введённый вами гамильтониан: H = {a}*{sigma}_{sigma_1} + {b}*{sigma}_{sigma_2} + {c}*{sigma}_{sigma_3}");
		string[] sigma_array = Hamiltonian.countingOperators(sigma_1, sigma_2, sigma_3);

		Console.WriteLine($"H^2 = {Hamiltonian.calculateSecondDegreeOfHamiltonian(Convert.ToDouble(a), Convert.ToDouble(b), sigma_array)}");
		Console.WriteLine($"H^3 = {Hamiltonian.calculateThirdDegreeOfHamiltonian(Convert.ToDouble(a), Convert.ToDouble(b), Convert.ToDouble(c), sigma_1, sigma_2,sigma_array)}");
	}
	class Calculation
	{
		public static string PauliMatrices(string K, string L)
		{
			char[] K1 = K.ToCharArray();
			char[] L1 = L.ToCharArray();
			string M = "";
			int a, b, c;
			if (K1.Length == L1.Length)
			{
				for (int i = 0; i < K1.Length; i++)
				{
					a = K1[i] - '0';
					b = L1[i] - '0';
					c = Calculation.Operations(a, b);
					M = M + Convert.ToString(c);
				}
				return M;
			}
			else
			{
				Console.WriteLine(" Ошибка размерности кубитов двух операторов");
				return "";
			};
		}
		public static int Operations(int a, int b)
		{
			int c;
			if (a == b) c = 0;
			else if (a == 0) c = b;
			else if (b == 0) c = a;
			else c = 6 / (a * b);
			return c;
		}
		public static string Factors(string K, string L)
		{
			char[] K1 = K.ToCharArray();
			char[] L1 = L.ToCharArray();
			int a, b, skl, p = 0, m = 0;
			string w = "";
			if (K1.Length == L1.Length)
			{
				for (int i = 0; i < K1.Length; i++)
				{
					a = K1[i] - '0';
					b = L1[i] - '0';
					if (a - b == 1 || a - b == -2) m++;
					if (b - a == 1 || b - a == -2) p++;
					p = p + m;
				}
				if (p % 4 == 0 || p % 4 == 1)
				{
					skl = Convert.ToInt32(Math.Pow(-1, m));
					if (skl == 1) w = "";
					else w = "-1";
				}
				if (p % 4 == 2 || p % 4 == 3)
				{
					skl = Convert.ToInt32(Math.Pow(-1, m + 1));
					if (skl == 1) w = "i";
					else w = "-i";
				}
			}
			return w;
		}
	}
	class Hamiltonian
	{
		public static string[] countingOperators(string sigma_1, string sigma_2, string sigma_3)
		{
			string sigma_12 = Calculation.Factors(sigma_1, sigma_2) + $"*{sigma}_" + Calculation.PauliMatrices(sigma_1, sigma_2);
			string sigma_23 = Calculation.Factors(sigma_2, sigma_3) + $"*{sigma}_" + Calculation.PauliMatrices(sigma_2, sigma_3);
			string sigma_12_indexes = sigma_12.Split("_")[sigma_12.Split("_").Length - 1];
			string sigma_123_draft = Calculation.Factors(sigma_12_indexes, sigma_3) + $"*{sigma}_" + Calculation.PauliMatrices(sigma_12_indexes, sigma_3);
			string sigma_123;

			if (sigma_12.StartsWith("-1"))
			{
				if (sigma_123_draft.StartsWith("-i"))
				{
					sigma_123 = $"i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else if (sigma_123_draft.StartsWith("i"))
				{
					sigma_123 = $"-i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else if (sigma_123_draft.StartsWith("-1"))
				{
					sigma_123 = $"{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else
				{
					sigma_123 = $"-1*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
			}
			else if (sigma_12.StartsWith("-i"))
			{
				if (sigma_123_draft.StartsWith("-i"))
				{
					sigma_123 = $"-1*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else if (sigma_123_draft.StartsWith("i"))
				{
					sigma_123 = $"{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else if (sigma_123_draft.StartsWith("-1"))
				{
					sigma_123 = $"i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else
				{
					sigma_123 = $"-i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
			}
			else if (sigma_12.StartsWith("i"))
			{
				if (sigma_123_draft.StartsWith("-i"))
				{
					sigma_123 = $"{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else if (sigma_123_draft.StartsWith("i"))
				{
					sigma_123 = $"-1*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else if (sigma_123_draft.StartsWith("-1"))
				{
					sigma_123 = $"-i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
				else
				{
					sigma_123 = $"i*{sigma}_{sigma_123_draft.Split("_")[sigma_123_draft.Split("_").Length - 1]}";
				}
			}
			else
			{
				sigma_123 = sigma_123_draft;
			}
			string[] sigma_array = new string[] { sigma_12, sigma_23, sigma_123 };
			return sigma_array;
		}

		public static string calculateSecondDegreeOfHamiltonian(double alpha, double beta, string[] arrayOfSigma)
		{
			return $"{sigma}_000 + {2 * alpha* beta}*{arrayOfSigma[0]}";
		}
		public static string calculateThirdDegreeOfHamiltonian(double alpha, double beta, double gamma, string sigma_1, string sigma_2, string[] arrayOfSigma)
		{
			return $"H + {2 * alpha * Math.Pow(beta, 2)}*{sigma}_{sigma_1}+{2 * Math.Pow(beta, 2) * beta}*{sigma}_{sigma_2} + {2 * alpha * beta * gamma}*{arrayOfSigma[2]}";
		}
	}
}
\end{lstlisting}

\end{document}
